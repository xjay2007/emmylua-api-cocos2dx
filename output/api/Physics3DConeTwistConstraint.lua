--------------------------------
--- generated by EmmyLua-Api-Cocos2dx-Generator
--------------------------------

---@class cc.Physics3DConeTwistConstraint : cc.Physics3DConstraint
local m = {}

--- get B's frame
---@return mat4_table
function m:getBFrame() end

--- set fix thresh
---@param fixThresh float
---@return cc.Physics3DConeTwistConstraint
function m:setFixThresh(fixThresh) end

--- get B's frame offset
---@return mat4_table
function m:getFrameOffsetB() end

--- get A's frame offset
---@return mat4_table
function m:getFrameOffsetA() end

--- get fix thresh
---@return float
function m:getFixThresh() end

--- get swing span2
---@return float
function m:getSwingSpan2() end

--- get swing span1
---@return float
function m:getSwingSpan1() end

--- set max motor impulse
---@param maxMotorImpulse float
---@return cc.Physics3DConeTwistConstraint
function m:setMaxMotorImpulse(maxMotorImpulse) end

--- set A and B's frame
---@param frameA mat4_table
---@param frameB mat4_table
---@return cc.Physics3DConeTwistConstraint
function m:setFrames(frameA, frameB) end

--- get twist angle
---@return float
function m:getTwistAngle() end

--- get point for angle
---@param fAngleInRadians float
---@param fLength float
---@return cc.vec3
function m:GetPointForAngle(fAngleInRadians, fLength) end

--- set max motor impulse normalize
---@param maxMotorImpulse float
---@return cc.Physics3DConeTwistConstraint
function m:setMaxMotorImpulseNormalized(maxMotorImpulse) end

--- get twist span
---@return float
function m:getTwistSpan() end

--- set damping
---@param damping float
---@return cc.Physics3DConeTwistConstraint
function m:setDamping(damping) end

--- set limits<br>
--- param swingSpan1 swing span1<br>
--- param swingSpan2 swing span2<br>
--- param twistSpan twist span<br>
--- param softness 0->1, recommend ~0.8->1. Describes % of limits where movement is free. Beyond this softness %, the limit is gradually enforced until the "hard" (1.0) limit is reached.<br>
--- param biasFactor 0->1?, recommend 0.3 +/-0.3 or so. Strength with which constraint resists zeroth order (angular, not angular velocity) limit violation.<br>
--- param relaxationFactor 0->1, recommend to stay near 1. the lower the value, the less the constraint will fight velocities which violate the angular limits.
---@param swingSpan1 float
---@param swingSpan2 float
---@param twistSpan float
---@param softness float
---@param biasFactor float
---@param relaxationFactor float
---@return cc.Physics3DConeTwistConstraint
function m:setLimit(swingSpan1, swingSpan2, twistSpan, softness, biasFactor, relaxationFactor) end

--- get A's frame
---@return mat4_table
function m:getAFrame() end

--- enable motor
---@param b boolean
---@return cc.Physics3DConeTwistConstraint
function m:enableMotor(b) end

---@overload fun(self:cc.Physics3DConeTwistConstraint, rbA:cc.Physics3DRigidBody, rbB:mat4_table):cc.Physics3DConeTwistConstraint
---@param rbA cc.Physics3DRigidBody
---@param rbB cc.Physics3DRigidBody
---@param frameA mat4_table
---@param frameB mat4_table
---@return cc.Physics3DConeTwistConstraint
function m:create(rbA, rbB, frameA, frameB) end

--- 
---@return cc.Physics3DConeTwistConstraint
function m:Physics3DConeTwistConstraint() end



return m